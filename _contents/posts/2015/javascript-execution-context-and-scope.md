---
title: Javascript 的执行环境(execution context)和作用域(scope)及垃圾回收
author: 高国良
type: posts
series: false
date: 2015-08-22T22:03:00.791Z
tags: [javascript, debug, context]
description: 执行环境有全局执行环境和函数执行环境之分，每次进入一个新执行环境，都会创建一个搜索变量和函数的作用域链。函数的局部环境不仅有权访问函数作用于中的变量，而且可以访问其外部环境，直到全局环境。全局执行环境只能访问全局执行环境的变量和函数，不能直接访问局部环境中的信息；
cover: false
---

执行环境有全局执行环境和函数执行环境之分，每次进入一个新执行环境，都会创建一个搜索变量和函数的作用域链。
函数的局部环境不仅有权访问函数作用于中的变量，而且可以访问其外部环境，直到全局环境。
全局执行环境只能访问全局执行环境的变量和函数，不能直接访问局部环境中的信息；
变量的执行环境有助于确定何时应该释放内存。离开作用域的值会被标记为可以回收，将在垃圾收集期间被删除。
javascript中有 **标记清除** 和 **引用计数** 两种垃圾收集算法。

## 执行环境


执行环境 (execution context) 是 Javascript 中很重要的一个概念。变量或函数的 execution context定义它们有权访问的其它数据，以及变量或函数各自的行为。每个执行环境都有一个与之关联的 **变量对象**（variable object） ，环境中定义的所有变量和函数都保存在这个对象中。我们编写的代码无法访问到这个对象，但是解析器在处理数据时会在后台使用它。

全局执行环境是最外围的一个执行环境，根据 ECMAScript 实现坐在的宿主环境的不同，表示执行环境的对象也不同。浏览器中，全局执行环境被认为是window对象，所有的全局变量和函数都作为window对象的属性或方法存在。

某个执行环境中的代码一旦执行完毕，该环境会被销毁，保存在其中的变量、函数都将随之销毁。每个函数都有一个自己的执行环境。全局执行环境会直到应用程序退出才会被销毁，比如关闭网页。

## 作用域链

scope chain

当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链可以看作是一个个变量对象的有机、有序连接，作用域链的第一个对象，始终都是当前执行的代码所在环境的**变量对象**。作用域链的下一个对象来自其外部环境，而在下一个对象则来自下一个外部环境，这样一直延续到全局执行环境。作用域链的最后一个对象始终都是全局执行环境的变量对象对象。如果执行环境是一个函数，则将其活动对象（activation object）作为变量对象。**活动对象**在最开始只包含一个变量，即arguments对象（全局环境中不存在该对象）。

标识符的解析就是沿着作用域链一级一级的搜索标识符的过程，知道找到标识符，如果标识符未被找到则会导致错误发生。如下所示：

```js
var name = "Zhang San";

function changeName()
{
    var newName = "Li Si";
    
    function execute(){
        var tempName = newName;
        newName = name;
        name = tempName;
        
        // 可以访问 name / newName / tempName
    }
    execute();
    // 可以访问 name / newName ， 不能访问 tempName
}
changeName();
// 只能访问 name
```

示例涉及3个执行环境：全局环境、`changeName()`的局部环境和 `execute()` 的局部环境。
内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。
这些环境之间的联系是线性、有序的。每个环境都可以向上搜索作用域，以查询变量和函数名；
但都不能向下搜索作用域链而进入另一个执行环境。

## 作用域链延长

尽管执行环境总共有全局执行环境和局部执行环境（函数）两种，但还是有一些语句会使作用域链的前段临时增加一个变量对象，改变量对象会在代码执行后被移除。
两种情况下会发生这种现象，当执行流进入下列任一语句时，作用域链就会得到加长：

1. catch块
2. with语句

## 没有块级作用域

javascript 没有块级作用域。在其他类 C 的语言中，由大括号封闭的代码都有自己的作用域，可以实现自根据条件来定义变量。

```js
if(true){
    var name = "Zhang San";
}
alert(name);    // "Zhan San"
```

如上例所示，变量 name 被添加到了当前的执行环境（即全局环境）中，如果在 C/C++/JAVA 的语言中变量 name 则会在if语句执行完毕后被销毁。下面在看一个例子：

```js
for(var i = 0; i < 10; i++){
    // code ...
}
alert(i);     //10
```

上例中，变量 i 并没有随着循环的结束而被销毁，而是被定义在了当前执行环境（全局环境）中，这一点要尤为注意。

## 声明变量

使用 var 关键字声明的变量会被自动添加到最接近的执行环境中，如果在函数内部，最接近的执行环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果没有使用 var 关键字定义变量，那么该变量会被添加到全局环境中。

```js
function getName(){
    var Name = "Zhang San";
    globalName = "Li Si";
    return Name;
}
getName(); // "Zhang San"
alert(globalName);    // "Li Si"
```

## 标识符查询

当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符的值。搜索过程从作用域链的最前端开始逐级向上查找，直到匹配到变量名。在这条链路上一旦找到标识符则查询工作立即结束，变量就绪。搜索过程会一直追溯到全局环境，如果在全局环境中仍未匹配到改查询则说明变量为声明。

## 垃圾回收

javascript 具备垃圾回收机制，执行环节会负责管理代码执行过程中使用的内存。开发人员几乎不必去关注内存使用问题，分不配和回收内存完全实现了自动管理。垃圾回收机制的原理是：找出那些不再继续使用的变量，然后释放其占用的内存。垃圾收集器会按固定的时间间隔周期性的执行这一操作。

函数中局部变量的生命周期：局部变量只在函数执行过程中存在，在这个过程中会为局部变量分配内存以存储他们的值，然后函数中使用这些变量进行一系列操作。当函数执行完毕，这些局部变量也就没有存在的价值了，可以释放他们的内存一共将来使用。

垃圾收集器必须跟踪变量的状态，以确定它们是否已经不会再被使用，对于不再使用的变量打上标记，以备将来收回其占用的内存。如此一来，标识无用变量的策略就显得尤为重要，具体到浏览器中，通常有两种策略。

### 标记清除（Mark-and-Sweep）

最常用的垃圾收集策略就是标记清除，当一个变量进入执行环境(context)，例如在函数中生命了一个变量，则这个变量会被标记为进入执行环境（ begin in context），理论上标记为进入环境的变量是不能被回收的。当变量离开执行环境，则将其标记为离开环境(out of context)。

当垃圾收集器运行时，会为所有存储在内存中的变量加上标记，然后取消 在当前执行环境中的变量和被当前执行环境中变量引用的变量 的标记。现在，所有被加上标记的变量都被认为是可以删除的变量，接着，垃圾收集器会便开始了他的内存清除工作，收回那些无效变量占用的内存。

> 不同浏览器都实用类类似的垃圾收集策略，只不过垃圾收集器运行的时间间隔不同。

### 引用计数（reference counting）

另一种垃圾收集机制是引用计数，这种策会跟踪记录每个值被引用的次数，当声明一个变量并赋值一个引用类型值时，这个值的引用次数就加会1。如果，包含对这个值的引用被取消，或者该变量有被赋值为其它值，则这个引用类型的值的引用次数就会减1。如果这个引用类型的值的引用次数为0，那么它将被垃圾回收机制回收。

这种回收策略有一个限制，就是当代码中存在循环引用时，相关对象的引用计数就永远不会为0，对象也就无法被回收。除非开发人员，明确的为相关对象解除引用。
